---
title: "363 final project"
output: html_document
date: "2024-04-30"
---

rm(list=ls())


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
##read relevant packages
library(car)
library(heplots)
library(MASS)
library(biotools)
library(klaR)
library(dplyr)
library(lubridate)
library(ggplot2)
library(ggExtra)
library(corrplot)
library(PerformanceAnalytics)
library(heplots)
```


```{r}
og_spotify <- read.csv("spotify-2023.csv")
colnames(og_spotify)

# Keep rows where the City column contains "New York"
spotify2023 <- og_spotify[grepl("2023", og_spotify$released_year), ]
dim(spotify2023)
head(spotify2023)


#Select the variables that we will be using 
spotifydata <- na.omit(spotify2023[c("track_name", "released_month", "in_spotify_playlists", "in_spotify_charts", "streams", "bpm", "mode", "danceability_.", "energy_.")])
dim(spotifydata)

#To make the track names become the row names, we must remove the duplicates 
clean_spotify <- spotifydata[!duplicated(spotifydata[c("track_name")]), ]
row.names(clean_spotify) <- clean_spotify$track_name
clean_spotify$streams <- as.integer(clean_spotify$streams)
dim(clean_spotify)
str(clean_spotify)

```
*The chosen variables are as follows:*

* released_month - Categorical variable 
* in_spotify_playlists - Continuous variable
* in_spotify_charts - Continuous variable
* streams - Continuous variable 
* bpm - continuous variable
* mode - Categorical variable
* danceability_. - Continuous variable
* energy_. - Continuous variable 


```{r}
##Assess normality of the data 

qqPlot(clean_spotify$in_spotify_playlists, col = 'red', pch = 19, main = "Normal Quantile Plot for in_spotify_playlist")
qqPlot(clean_spotify$in_spotify_charts, col = 'red', pch = 19, main = "Normal Quantile Plot for in_spotify_charts")
qqPlot(clean_spotify$streams, col = 'red', pch = 19, main = "Normal Quantile Plot for streams")
qqPlot(clean_spotify$bpm, col = 'red', pch = 19, main = "Normal Quantile Plot for bpm")
qqPlot(clean_spotify$danceability_., col = 'red', pch = 19, main = "Normal Quantile Plot for danceability")
qqPlot(clean_spotify$energy_., col = 'red', pch = 19, main = "Normal Quantile Plot for energy")

##The spotify playlist, spotify charts, and streams data is not normal based on the plot, so we will perform transformations.

clean_spotify$logplaylist <- log(clean_spotify$in_spotify_playlists)
clean_spotify$logcharts <- log(clean_spotify$in_spotify_charts)
summary(clean_spotify$logcharts)
clean_spotify$logcharts[!is.finite(clean_spotify$logcharts)] <- NA
clean_spotify$logstreams <- log(clean_spotify$streams)


qqPlot(clean_spotify$logplaylist, col = 'red', pch = 19, main = "Normal Quantile Plot for transformed in_spotify_playlist")
qqPlot(clean_spotify$logcharts, col = 'red', pch = 19, main = "Normal Quantile Plot for transformed in_spotify charts")
qqPlot(clean_spotify$logstreams, col = 'red', pch = 19, main = "Normal Quantile Plot for transformed streams")

```


```{r}
##Multivariate Normality
colnames(clean_spotify)
trans_spotify <- clean_spotify[complete.cases(clean_spotify[, c(10, 11, 12, 6, 8, 9)]), ]
rownames(trans_spotify)
str(trans_spotify[, c(10, 11, 12, 6, 8, 9)])

source("http://www.reuningscherer.net/multivariate/R/CSQPlot.r.txt")

CSQPlot(trans_spotify[, c(10, 11, 12, 6, 8, 9)], label = "Transformed Spotify 2023 Data")

```

*Based on the plots above, we can see that the transformed continuous variables chosen from the Spotify dataset show both univariate and multivariate normality.*



## PCA 

*For this segment, we are using the following continuous variables to perform PCA:* 

* bpm - 
* danceability_. - 
* energy_. - 
* logplaylists - 
* logcharts
* logstreams

```{r}
##Firstly, we check the correlations and linearity of the model. 
trans_spotify <- clean_spotify[complete.cases(clean_spotify[, c(10, 11, 12, 6, 8, 9)]), ]
names(trans_spotify)


round(cor(trans_spotify[, c(10, 11, 12, 6, 8, 9)]), 2)
corrplot(cor(trans_spotify[, c(10, 11, 12, 6, 8, 9)]), method = "ellipse")
chart.Correlation(trans_spotify[, c(10, 11, 12, 6, 8, 9)])
```


```{r}
pc1 <- princomp((trans_spotify[, c(10, 11, 12, 6, 8, 9, 2)]), cor = TRUE)
names(pc1)
summary(pc1)
print(pc1$loadings, cutoff = 0, digits = 2)

#Get eigenvalues
round(pc1$sdev^2,2)

#Screeplot for the PCA
screeplot(pc1, type = "lines", col = "red", lwd = 2, pch = 19, cex = 1.2, 
          main = "Scree Plot of Transformed Spotify Data")
```

```{r}
#Performing parallel analysis 
source("http://www.reuningscherer.net/multivariate/R/parallel.r.txt")
parallelplot(pc1)
```

```{r}

trans_spotify[, 1] <- stringi::stri_replace_all_regex(trans_spotify[, 1], "[^\x01-\x7F]", "")

library(FactoMineR)
rownames(trans_spotify) <- trans_spotify[, 1]
rownames(trans_spotify)
# Remove non-ASCII characters from all character columns
# Convert the encoding of the first column to UTF-8

#The PCA function scales variables by default, and gives a scoreplot and a 'correlation' biplot.  Notice results are flipped vertically from results above.

par(cex = .8, col = "blue")
pc2 <- PCA((trans_spotify[, c(10, 11, 12, 6, 8, 9, 2)]))
dev.off()
summary(pc2)
```


##Discriminant Analysis

*For DA, we are using the following categorical and continuous variables:*

* Mode - whether a song is major or minor
* Danceability - how well can a song be danced to (based on a numerical percentage)
* BPM - the beats per minute of the song


```{r}
#Select the variables 

DAspotify <- na.omit(spotify2023[c("bpm", "mode", "danceability_.")])
dim(DAspotify)

#Making boxplots of the relationships

boxplot(bpm ~ mode, data=DAspotify, col = c("red","blue"), horizontal = T, main = "BPM by Mode of Song")

boxplot(danceability_. ~ mode, data=DAspotify, col = c("red","blue"), horizontal = T, main = "Danceability by Mode of Song")

```

```{r}

library(car)
stream_lm <- lm(trans_spotify$streams ~ trans_spotify$in_spotify_playlists, data = trans_spotify)

plot(trans_spotify$streams ~ trans_spotify$in_spotify_playlist, 
     pch=19,
     main = "Spotify Streams to Playlist",
     xlab = "Playlist",
     ylab = "Streams",
     data = trans_spotify,
     col = "lightpink")
coefs <- coef(stream_lm)
abline(a = coefs[1], b = coefs[2], col = "red", lwd = 3)


stream_lm2 <- lm(trans_spotify$streams ~ trans_spotify$in_spotify_charts, data = trans_spotify)

plot(trans_spotify$streams ~ trans_spotify$in_spotify_charts, 
     pch=19,
     main = "Spotify Streams to Charts",
     xlab = "Chart",
     ylab = "Streams",
     data = trans_spotify,
     col = "lightpink")
coefs <- coef(stream_lm2)
abline(a = coefs[1], b = coefs[2], col = "red", lwd = 3)



bpm_lm <- lm(trans_spotify$bpm ~ trans_spotify$energy_., data = trans_spotify)

plot(trans_spotify$bpm ~ trans_spotify$energy_., 
     pch=19,
     main = "Spotify Bpm to Energy",
     xlab = "Chart",
     ylab = "Streams",
     data = trans_spotify,
     col = "lightpink")
coefs <- coef(bpm_lm)
abline(a = coefs[1], b = coefs[2], col = "red", lwd = 3)


bpm_lm2 <- lm(trans_spotify$bpm ~ trans_spotify$danceability_., data = trans_spotify)

plot(trans_spotify$bpm ~ trans_spotify$danceability_., 
     pch=19,
     main = "Spotify Streams to Charts",
     xlab = "Chart",
     ylab = "Bpm",
     data = trans_spotify,
     col = "lightpink")
coefs <- coef(bpm_lm2)
abline(a = coefs[1], b = coefs[2], col = "red", lwd = 3)
```

```{r}
#make matrix plot to look at differences between groups
plot(forbs[,4:8], col = forbs[,2]+2, pch = forbs[,2] + 15, cex = 1.2)
```


